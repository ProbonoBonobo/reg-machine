<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1479344319636">{:repl-history {:ide [], :local [&quot;db&quot; &quot;(defn load-inst [subroutine]\n  (do\n    (swap! db assoc-in [:queue :val] (into (get-in @db [:queue :val]) subroutine))\n    (swap! db update-in [:queue :rear-ptr] + (count (into [] subroutine)))\n    (swap! db assoc-in [:queue :state] 2)))\n&quot; &quot;()(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr]}\n                 :queue {:val []\n                         :front-ptr 0\n                         :rear-ptr 0\n                         :state 0\n                         :children []}}))&quot; &quot;ref&quot; &quot;(defn refpath [t]\n  (if (contains? (into #{} (keys (get-in @db :refs))) t)\n    (get-in @db :refs)\n    :unknown))&quot; &quot;(defn refpath [t]\n  (if (contains? (into #{} (keys (get-in @db [:refs]))) t)\n    (get-in @db [:refs t])\n    :unknown))&quot; &quot;:(defn refpath [t]\n   (if (contains? (into #{} (keys (get-in @db [:refs]))) t)\n     (get-in @db [:refs t])\n     :unknown))\n\n(defn resolve [path]\n  (if (and (keyword? path)\n           (contains? (into #{} (keys (get-in @db [:refs]))) path))\n    (get-in @db (refpath path))\n    (get-in @db (path))))&quot; &quot;(defn refpath [t]\n  (if (contains? (into #{} (keys (get-in @db [:refs]))) t)\n    (get-in @db [:refs t])\n    :unknown))\n\n(defn resolve [path]\n  (if (and (keyword? path)\n           (contains? (into #{} (keys (get-in @db [:refs]))) path))\n    (get-in @db (refpath path))\n    (get-in @db (path))))&quot; &quot;(resolve :r1)&quot; &quot;(defn resolve [path]\n  (if (and (keyword? path)\n           (contains? (into #{} (keys (get-in @db [:refs]))) path))\n    (get-in @db (refpath path))\n    (get-in @db path)))&quot; &quot;(refpath :front-ptr)&quot; &quot;(resolve :rear-ptr)&quot; &quot;(resolve [:queue :val])&quot; &quot;(take 1 (resolve [:queue :val]))&quot; &quot;(take-while #(not (= (resolve :front-ptr) (resolve :rear-ptr))) (resolve [:queue :val]))&quot; &quot;(take-while (not (= (resolve :front-ptr) (resolve :rear-ptr))) (resolve [:queue :val]))&quot; &quot;(take-while (&lt; (resolve :front-ptr) (resolve :rear-ptr)) (resolve [:queue :val]))&quot; &quot;(take-while true? (resolve [:queue :val]))&quot; &quot;(take-while true (resolve [:queue :val]))&quot; &quot;(take-while #(apply (cadr %) (cadar %)) \n            (resolve [:queue :val]))&quot; &quot;(nth (resolve [:queue :val]) 2)&quot; &quot;(caar (nth (resolve [:queue :val]) 2))&quot; &quot;(car (nth (resolve [:queue :val]) 2)&quot; &quot;(car (nth (resolve [:queue :val]) 2))&quot; &quot;(cdr (nth (resolve [:queue :val]) 2))&quot; &quot;(second\n  (nth (resolve [:queue :val]) 2))&quot; &quot;(boolean? true)&quot; &quot;(bool? true)&quot; &quot;(eq? 3 4)&quot; &quot;(equal? 4 3)&quot; &quot;(= 3 2)&quot; &quot;(= true 1)&quot; &quot;(== true 1)&quot; &quot;(defn boolean? [x]\n  (or (true? x) (false? x)))\n\n(defn int-&gt;bool [i]\n  (if (and (number? i)\n           (= 1 i))\n    true\n    false))\n\n(defn bool-&gt;int [b]\n  (if (boolean? b)\n    (if (true? b)\n      1\n      0)\n    -1))\n&quot; &quot;(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val []\n                       :front-ptr 0\n                       :rear-ptr 0\n                       :state 0\n                       :children []}}))&quot; &quot;(nth (resolve :queue-val) (resolve :front-ptr))&quot; &quot;(constantly \&quot;empty\&quot;)&quot; &quot;(apply constantly [\&quot;empty\&quot;])&quot; &quot;(apply take [1 (constantly \&quot;empty\&quot;)])&quot; &quot;(def empty (constantly \&quot;Empty!\&quot;))&quot; &quot;(take 1 empty)&quot; &quot;(take 5 [empty])&quot; &quot;(apply empty [])&quot; &quot;\n(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val [[(constantly :empty) [])]]\n:front-ptr 0\n:rear-ptr 0\n:state 0\n:children []}}))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (apply f args)\n    (swap! db update-in (refpath :front-ptr) inc)\n    (swap! db update-in (refpath :queue-state) (bool-&gt;int\n                                                 (= (resolve :front-ptr)\n                                                    (resolve :rear-ptr))))))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc)\n      (swap! db update-in (refpath :queue-state) (bool-&gt;int\n                                                   (= (resolve :front-ptr)\n                                                      (resolve :rear-ptr)))))))&quot; &quot;(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val [[(constantly :empty) []]]\n                       :front-ptr 0\n                       :rear-ptr 0\n                       :state 0\n                       :children []}}))&quot; &quot;(resolve :front-ptr)&quot; &quot;(resolve :queue-val)&quot; &quot;(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val [[str [\&quot;Empty!\&quot;]]]\n                       :front-ptr 0\n                       :rear-ptr 0\n                       :state 0\n                       :children []}}))&quot; &quot;(defn bool-&gt;int [b]\n  (if (boolean? b)\n    (if (true? b)\n      1\n      0)))&quot; &quot;(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val [[str [\&quot;Empty!\&quot;]]]\n                       :front-ptr 0\n                       :rear-ptr 1\n                       :state 0\n                       :children []}}))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (str f \&quot;, \&quot; args)))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (apply f args)))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc))))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc)\n      (swap! db update-in (refpath :queue-state)  (= (resolve :front-ptr)\n                                                     (resolve :rear-ptr))))))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc)\n      (swap! db assoc-in (refpath :queue-state)  (= (resolve :front-ptr)\n                                                    (resolve :rear-ptr))))))&quot; &quot;(type true)&quot; &quot;(defn ^boolean boolean\n  \&quot;Coerce to boolean\&quot;\n  [x]\n  (cond\n    (nil? x) false\n    (false? x) false\n    :else true))&quot; &quot;(defn ^boolean boolean\n  \&quot;Coerce to boolean\&quot;\n  [x]\n  (cond\n    (zero? x) false\n    (empty? x) false\n    (nil? x) false\n    (false? x) false\n    :else true))&quot; &quot;(defn ^boolean boolean\n  \&quot;Coerce to boolean\&quot;\n  [x]\n  (cond\n    (zero? x) false\n    (nil? x) false\n    (false? x) false\n    :else true))&quot; &quot;(boolean 1)&quot; &quot;(boolean 0)&quot; &quot;(boolean \&quot;\&quot;)&quot; &quot;(zero? \&quot;\&quot;)&quot; &quot;(count 0)&quot; &quot;(defn int-&gt;bool [i]\n  (cond\n    (not (number? i)) nil\n    (zero? i) false\n    (&gt; i 0) true\n    :else nil))&quot; &quot;(int-&gt;bool 3)&quot; &quot;(defn boolean? [x]\n  (or (true? x) (false? x)))\n\n(defn int-&gt;bool [i]\n  (cond\n    (not (number? i)) nil\n    (zero? i) false\n    (&gt; i 0) true\n    :else nil))\n\n(defn bool-&gt;int [b]\n  (cond\n    (not (boolean? b)) nil\n    (true? b) 1\n    (false? b) 0\n    :else nil))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc)\n      (swap! db assoc-in (refpath :queue-state) (bool-&gt;int\n                                                  (= (resolve :front-ptr)\n                                                     (resolve :rear-ptr)))))))&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc)\n      (swap! db assoc-in (refpath :queue-state) (bit-not\n                                                  (bool-&gt;int\n                                                    (= (resolve :front-ptr)\n                                                       (resolve :rear-ptr))))))))&quot; &quot;(bit-flip 1)&quot; &quot;(bit-flip 1 0)&quot; &quot;(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val [[str [\&quot;Empty!\&quot;]] [str [\&quot;Empty!\&quot;]]]\n                       :front-ptr 0\n                       :rear-ptr 1\n                       :state 0\n                       :children []}}))\n&quot; &quot;(defn boolean? [x]\n  (or (true? x) (false? x)))\n\n(defn int-&gt;bool [i]\n  (cond\n    (not (number? i)) nil\n    (zero? i) false\n    (&gt; i 0) true\n    :else nil))\n\n(defn bool-&gt;int [b]\n  (cond\n    (not (boolean? b)) nil\n    (true? b) 1\n    (false? b) 0\n    :else nil))\n&quot; &quot;(reset-db)&quot; &quot;(bool-&gt;int (= (resolve :front-ptr) (resolve :rear-ptr)))&quot; &quot;(bit-flip 0 0)&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)]\n    (do\n      (apply f args)\n      (swap! db update-in (refpath :front-ptr) inc)\n      (swap! db assoc-in (refpath :queue-state) (if (= (resolve :front-ptr)\n                                                       (resolve :rear-ptr))\n                                                  0\n                                                  1)))))&quot; &quot;(defn IR [opcode]\n  (let [instructions {0 [[make-root-component [:registers]]\n                         [make-nested-component [:registers :r1]]\n                         [make-nested-component [:registers :op]]\n                         [make-nested-component [:registers :r2]]\n                         [make-nested-component [:registers :r3]]\n                         [str [\&quot;Empty!\&quot;]]]}]\n    (load-inst (get instructions opcode))))&quot; &quot;(contains? {:b 4 :c 5} :c)&quot; &quot;\n(defn make-root-component\n  ([k] (if-not (in-refs? k)\n         (do\n           (swap! db assoc k {:idx k :state 0 :val 0 :children {}})\n           (swap! db update-in [:refs] merge {k [k]}))\n         \&quot;Not overwriting the existing root component\&quot;))\n  ([k v] (if-not (in-refs? k)\n           (do\n             (swap! db assoc k v)\n             (swap! db update-in [:refs] merge {k [k]})))\n   \&quot;Not overwriting the existing root component\&quot;))\n\n(defn make-nested-component\n  ([parent k]\n   (let [root       (get-in @db [parent])\n         siblings   (get-in @db (into [] [parent :children]))\n         next-index (count siblings)]\n     (if-not (in-refs? k)\n       (do\n         (swap! db update-in [parent :children] conj {next-index {:idx k :state 0 :val 0 :children {}}})\n         (swap! db update-in [:refs] merge {k (into [] [parent :children next-index])}))\n       \&quot;Not overwriting the existing component\&quot;))))\n&quot; &quot;(defn in-refs? [k]\n  (contains? (get-in @db [:refs]) k))&quot; &quot;(defn make-root-component\n  ([k] (if-not (in-refs? k)\n         (do\n           (swap! db assoc k {:idx k :state 0 :val 0 :children {}})\n           (swap! db update-in [:refs] merge {k [k]}))\n         \&quot;Not overwriting the existing root component\&quot;))\n  ([k v] (if-not (in-refs? k)\n           (do\n             (swap! db assoc k v)\n             (swap! db update-in [:refs] merge {k [k]})))\n   \&quot;Not overwriting the existing root component\&quot;))\n\n(defn make-nested-component\n  ([parent k]\n   (let [root       (get-in @db [parent])\n         siblings   (get-in @db (into [] [parent :children]))\n         next-index (count siblings)]\n     (if-not (in-refs? k)\n       (do\n         (swap! db update-in [parent :children] conj {next-index {:idx k :state 0 :val 0 :children {}}})\n         (swap! db update-in [:refs] merge {k (into [] [parent :children next-index])}))\n       \&quot;Not overwriting the existing component\&quot;))))\n&quot; &quot;(make-nested-component :registers \&quot;balls\&quot;)&quot; &quot;(make-nested-component :registers :r1)&quot; &quot;(defn process-queue []\n  (let [next-instruction (nth (resolve :queue-val) (resolve :front-ptr))\n        f (first next-instruction)\n        args (second next-instruction)\n        has-next? (int-&gt;bool (resolve :queue-state))]\n    (if has-next?\n      (do\n        (apply f args)\n        (swap! db update-in (refpath :front-ptr) inc)\n        (swap! db assoc-in (refpath :queue-state) (if (= (resolve :front-ptr)\n                                                         (resolve :rear-ptr))\n                                                    0\n                                                    1)))\n      :update-complete)))&quot; &quot;(def db (atom {:refs {:queue [:queue] :front-ptr [:queue :front-ptr] :rear-ptr [:queue :rear-ptr] :queue-val [:queue :val] :queue-state [:queue :state]}\n               :queue {:val [[str [\&quot;Empty!\&quot;]] [str [\&quot;Empty!\&quot;]]]\n                       :front-ptr 0\n                       :rear-ptr 1\n                       :state 0\n                       :children []}}))&quot; &quot;(IR 0)&quot; &quot;(process-queue)&quot; &quot;(active-register)&quot; &quot;(defprotocol Dog\n  (sit [this]\n    (bark [this])\n    (eat [this]\n         (deftype Terrier\n           Dog\n           (sit [this]\n             (prn \&quot;sitting\&quot;))\n           (bark [this]\n             (prn \&quot;woof!\&quot;))\n           (eat [this]\n             (prn \&quot;nom nom nom!\&quot;)))\n         (defn new-terrier []\n           (Terrier.)))))&quot; &quot;(defprotocol Dog\n  (sit [this])\n    (bark [this])\n    (eat [this]))\n         (deftype Terrier\n           Dog\n           (sit [this]\n             (prn \&quot;sitting\&quot;))\n           (bark [this]\n             (prn \&quot;woof!\&quot;))\n           (eat [this]\n             (prn \&quot;nom nom nom!\&quot;)))\n         (defn new-terrier []\n           (Terrier.))&quot; &quot;(defprotocol Dog\n  (sit [this])\n  (bark [this])\n  (eat [this]))&quot; &quot;(deftype Terrier\n  Dog\n  (sit [this]\n    (prn \&quot;sitting\&quot;))\n  (bark [this]\n    (prn \&quot;woof!\&quot;))\n  (eat [this]\n    (prn \&quot;nom nom nom!\&quot;)))&quot; &quot;(deftype Terrier []\n  Dog\n  (sit [this]\n    (prn \&quot;sitting\&quot;))\n  (bark [this]\n    (prn \&quot;woof!\&quot;))\n  (eat [this]\n    (prn \&quot;nom nom nom!\&quot;)))&quot; &quot;(defn new-terrier []\n  (Terrier.))&quot; &quot;()&quot; &quot;(def terrier (new-terrier))&quot; &quot;(bark terrier)&quot; &quot;(in-ns 'succulent.core)&quot;], :remote []}}</component>
</project>