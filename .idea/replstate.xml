<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1479783501664">{:repl-history {:ide [], :local [&quot;(handle \&quot;2\&quot;)&quot; &quot;(handle \&quot;9\&quot;)&quot; &quot;(reset! db clear)&quot; &quot;(swap! db assoc (clear))&quot; &quot;(swap! db assoc (clear) [:val])&quot; &quot;(swap! db assoc [:val] (clear))&quot; &quot;(swap! db update-in [:val] clear)&quot; &quot;(swap! db update clear)&quot; &quot;(swap! db update db clear)&quot; &quot;(swap! db update [] clear)&quot; &quot;(swap! db apply clear)&quot; &quot;(swap! db apply [this] clear)&quot; &quot;(swap! db apply [:val] clear)&quot; &quot;(swap! db apply clear @db)&quot; &quot;(swap! db apply clear [])&quot; &quot;(swap! db apply reset-db [])&quot; &quot;(handle \&quot;4\&quot;)&quot; &quot;(handle \&quot;5\&quot;)&quot; &quot;(handle \&quot;+\&quot;)&quot; &quot;(handle \&quot;3\&quot;)&quot; &quot;(handle \&quot;=\&quot;)&quot; &quot;(handle \&quot;1\&quot;)&quot; &quot;(seq (vec (fn [x] (cond (true?) \&quot;hooray\&quot;))))&quot; &quot;(vec (fn [x] (cond (true?) \&quot;hooray\&quot;)))&quot; &quot;(vec (fn [x] (cond (true? true) \&quot;hooray\&quot;)))&quot; &quot;(fn [x] (cond (true? true) \&quot;hooray\&quot;))&quot; &quot;(seq (fn [x] (cond (true? true) \&quot;hooray\&quot;)))&quot; &quot;(lazy-seq (fn [x] (cond (true? true) \&quot;hooray\&quot;)))&quot; &quot;(vec #(\&quot;test\&quot;))&quot; &quot;(vec [#(%)])&quot; &quot;(seq [(fn [x] (cond (true? true) \&quot;hooray\&quot;))])&quot; &quot;(def vecmeth (seq [(fn [x] (cond (true? true) \&quot;hooray\&quot;)) (fn [x] (cond (true? true) \&quot;neat\&quot;))))&quot; &quot;(def vecmeth (seq [(fn [x] (cond (true? true) \&quot;hooray\&quot;)) (fn [x] (cond (true? true) \&quot;neat\&quot;))]))&quot; &quot;vecmeth&quot; &quot;(nth vecmeth 1)&quot; &quot;(apply (nth vecmeth 1) 1)&quot; &quot;(apply (nth vecmeth 1) [1])&quot; &quot;(asciitable \&quot;5\&quot;)&quot; &quot;(number 5)&quot; &quot;(opcode)&quot; &quot;(dispatch 1)&quot; &quot;(apply (dispatch 1) [\&quot;5\&quot; :number])&quot; &quot;(L2dispatch \&quot;5\&quot; :number)&quot; &quot;(asciitable \&quot;+\&quot;)&quot; &quot;(L2dispatch \&quot;2\&quot; :number)&quot; &quot;(L2dispatch \&quot;+\&quot; :operator)&quot; &quot;(L2dispatch \&quot;4\&quot; :operator)&quot; &quot;(L2dispatch \&quot;4\&quot; :number)&quot; &quot;(L2dispatch \&quot;9\&quot; :number)&quot; &quot;(L2dispatch \&quot;+\&quot; :number)&quot; &quot;(L2dispatch \&quot;3\&quot; :number)&quot; &quot;(L2dispatch \&quot;*\&quot; :operator)&quot; &quot;(stat! :op 1)&quot; &quot;(L2dispatch \&quot;1\&quot; :number)&quot; &quot;(L2dispatch \&quot;*\&quot; :number)&quot; &quot;(defn p [chr]\n  (L1dispatch chr (second (asciilookup chr))))&quot; &quot;(p \&quot;5\&quot;)&quot; &quot;(p \&quot;9\&quot;)&quot; &quot;(p \&quot;+\&quot;)&quot; &quot;(get-opcode)&quot; &quot;(p \&quot;*\&quot;)&quot; &quot;(p \&quot;3\&quot;)&quot; &quot;(p \&quot;6\&quot;)&quot; &quot;(str/read-string \&quot;328349834\&quot;)&quot; &quot;(read-string \&quot;208430843\&quot;)&quot; &quot;(str/split \&quot;238249834\&quot; #\&quot;\\s\&quot;)&quot; &quot;(clojures.string/split \&quot;238249834\&quot; #\&quot;\\s\&quot;)&quot; &quot;(clojure.string/split \&quot;238249834\&quot; #\&quot;\\s\&quot;)&quot; &quot;(clojure.string/split \&quot;238249834\&quot; #\&quot;\\d\&quot;)&quot; &quot;(clojure.string/split \&quot;238249834\&quot;)&quot; &quot;(clojure.string/split \&quot;238249834\&quot; #\&quot;\&quot;)&quot; &quot;\n(defn stream-str [expr]\n  (doseq [chars (seq (clojure.string/split expr #\&quot;\&quot;))\n          :let [chr (str chars)]\n          :when true]\n    (println chr)))&quot; &quot;(defn stream-str [expr]\n  (doseq [chars (seq (clojure.string/split expr #\&quot;\&quot;))\n          :let [chr (str chars)]\n          :when true]\n    (println (str chr))))&quot; &quot;(defn stream-str [expr]\n  (doseq [chars (seq (clojure.string/split expr #\&quot;\&quot;))\n          :let [chr (str chars)]\n          :when true]\n    chr))&quot; &quot;(stream-str \&quot;23828+329032\&quot;)&quot; &quot;(defn stream-str [expr]\n  (doseq [chars (seq (clojure.string/split expr #\&quot;\&quot;))\n          :let [chr (handle (str chars))]\n          :when true]\n    (println chr)))&quot; &quot;(stream-str \&quot;294+23892\&quot;)&quot; &quot;(defn evaluate []\n  (let [x (str-&gt;int (ask :r1 :val))\n        y (str-&gt;int (ask :r2 :val))\n        op (atom2action (ask :op :val))]\n    (str (apply op [x y]))))&quot; &quot;(reset-db!)&quot; &quot;(stream-str \&quot;294+23892=\&quot;)&quot; &quot;(stat! :r3 1)&quot; &quot;db&quot; &quot;(empty? \&quot;\&quot;)&quot; &quot;(handle \&quot;-\&quot;)&quot; &quot;0000&quot; &quot;2r0000&quot; &quot;2r1000&quot; &quot;2r100000000000000000000000000000000000000000000000000000000&quot; &quot;2r1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot; &quot;app-state&quot; &quot;ls&quot; &quot;(boolean? 5)&quot; &quot;(in-ns 'succulent.core)&quot; &quot;ISeqable&quot; &quot;(require 'cljs.core)&quot; &quot;(clj-&gt;js (str \&quot;Hello world!\&quot;))&quot; &quot;((:require '[cljs.core :refer :all]))&quot; &quot;((:require '[cljs.core :refer [:all]]))&quot; &quot;((:require '[cljs.core :refer [all]]))&quot; &quot;(require cljs.core :refer [all])&quot; &quot;(require cljs.core :refer [:all])&quot;], :remote []}}</component>
</project>